# 파이썬 - 단위 테스트와 리팩토링  

## 단위 테스트 개념  
단위 테스트는 다른 코드의 일부분이 유효한지를 검사하는 코드로, 소프트웨어의 핵심이 되는 필수기능으로서 일반 비즈니스 로직과 동일한 수준으로 다뤄져야합니다.  
단위 테스트로 일반 비즈니스 로직이 특정 조건을 보장하는 지 확인하기 위해 여러 시나리오를 검증하는 코드를 작성합니다.  
이러한 단위 테스트는 소프트웨어 유지보수에 있어 중요한 역할을 담당하며 품질관리에 있어 필수항목 중 하나입니다.  

### 단위테스트의 특징
- 격리: 닥위 테스트는 다른 외부 에이전트와 완전히 독립적이어야 하며 비즈니스 로직에만 집중해야합니다.  
  - 데이터베이스 연결 or HTTP 요청 X
  - 테스트가 독립적이어야하기 때문에 이전 상태와 관계 없이 임의의 순서로 실행 가능 보장  
- 성능: 단위 테스트는 신속하게 수행되어야 하며 반복적으로 여러번 실행 가능하도록 설계되어야 합니다.  
- 자체검증: 단위테스트의 실행만으로 결과 검증이 가능해야하며 단위 테스트 처리를 위한 추가 단계가 없어야 합니다.  

### 단위테스트의 범위
단위 테스트는 함수 또는 메서드 같은 매우 작은 단위를 확인하여 코드를 최대한 자세하게 검사하는 용도입니다.  
만약 클래스를 테스트하고 싶은 경우라면 단위테스트의 집합인 테스트 스위트(test suite)를 이용하여 테스트 스위트를 구성하는 테스트들로 메서드처럼 보다 작은 단위를 테스트하면 됩니다.  

단위 테스트 외에도 통합테스트, 인수테스트 등이 있습니다.  
- 통합 테스트: 한 번에 여러 컴포넌트를 테스트하는 테스트입니다. 종합적으로 코드가 예상대로 동작하는 지를 검증합니다.
  - HTTP 요청이나 데이터베이스 연결 등이 모두 가능합니다.  
- 인수 테스트: 유스케이스(use case)를 활용하여 사용자의 관점에서 시스템의 유효성을 검사하는 자동화된 테스트입니다.  

통합테스트와 인수테스트는 단위테스트의 중요한 요소인 '속도'를 잃게 됩니다.  
따라서 테스트 실행에 더 많은 시간이 걸리기 때문에 덜 자주 실행하게 됩니다.  

## 단위테스트와 애자일 소프트웨어 개발  
최근의 소프트웨어 개발은 신속하고 지속적인 가치 제공을 목표로 합니다.  
이런 목표를 가지고 개발하는 이유는 더 빠르게 피드백을 받아 더 쉽게 코드를 수정하기 위함입니다.  
여러 변화 상황에 쉽게 대응하기 위해서는 유연하고 확장 가능한 코드를 작성해두어야 합니다.  

그러나 코드 자체만 가지고 변경에 충분히 유연하다는 보장을 할 수는 없습니다.  
소프트웨어 개발론을 잘 지킨 코드를 만들었고 쉽게 리팩토링이 가능하도록 작성되어있다고 하더라도 해당 코드에 대한 변경 작업이 아무런 버그 없이 작동할 수 있다는 보장 방법이 필요합니다.  
이에 대한 공식적인 증거를 제시할 수 있는 것이 바로 단위 테스트입니다.  
단위테스트는 프로그램이 명세에 따라 정확하게 동작한다는 것을 보장할 수 있습니다.  
좋은 단위테스트는 코드가 기대한 것처럼 동작한다는 확신을 줄 수 있으며 버그에 의해 프로젝트가 중단되지 않고 신속하게 가치를 제공할 가능성이 높아집니다.  

## 단위테스트와 소프트웨어 디자인  
소프트웨어 디자인과 단위테스트는 긴밀한 관계가 있습니다.  
좋은 소프트웨어는 테스트 가능한 소프트웨어이고 테스트의 용이성은 클린코드의 핵심 가치이기 떄문입니다.  

단위 테스트는 기본 코드 보완 용도라기 보다는 실제 코드의 작성 방식에 직접적인 영향을 미칩니다.  
단위 테스트는 특정 코드에 단위 테스트를 해야겠다고 발견하는 단계에서부터 더 나은 코드를 작성하는 단계, 궁극적으로 모든 코드가 테스트에 의해 작성되는 TDD 단계까지 여러 단계가 있습니다.  

단위 테스트 예제 코드를 살펴보며 단위 테스트를 통해 코드를 어떻게 개선시켜나갈 수 있는지 확인해보도록 하겠습니다.  
다음 예제는 프로세스 실행 중 오류가 생기면 에러 내용을 전송하는 클라이언트를 이용해 관리자에게 에러를 알리는 상황을 구현한 코드입니다.  
```py
import random

class ErrorAlertClient:
    """오류 발생 메시지 전송 클라이언트"""

    def send(self, error_channel, error_msg):
        if not isinstance(error_channel, str):
            raise TypeError("error_channel로 문자열 타입을 사용해야 함")
        if not isinstance(error_msg, str):
            raise TypeError("error_msg로 문자열 타입을 사용해야 함")

        print(f"{error_channel} 채널에 {error_msg} 오류 발생")


class Process:
    def __init__(self):
        self.client = ErrorAlertClient()
        self.channel = "channel_1"

    def process_iteration(self, n_interations):
        for i in range(n_interations):
            result = self.run_process()
            self.client.send(self.channel, result)

    def run_process(self):
        result_value = ["abc", "가나다", 0.1, 3]
        return random.choice(result_value)


if __name__ == "__main__":
    process = Process()
    process.process_iteration(4)
```
위 코드에서 `ErrorAlertClient`를 통해 에러 오류 메세지를 발송하고 싶다면 `send` 메서드의 인자로 string 형의 `error_channel`, `error_msg` 2개의 파라미터를 전달해야합니다.  
만약 파라미터로 문자열이 아닌 값을 전달한다면 오류가 발생하게 됩니다.  
`ErrorAlertClient`가 만약 외부 라이브러리라 직접 제어가 불가능한 상황이라면 더더욱 이러한 인터페이스 규약을 맞춰주어야 합니다.  
이러한 부분은 단위테스트를 통해 점검하고 문제 여부를 확인할 수 있습니다.  

