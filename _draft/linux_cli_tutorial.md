# 리눅스 기본 명령어 모음

## 리눅스 기본 파일 시스템 및 디렉터리 구조  
루트 디렉터리 내의 기본 구조는 다음과 같음  
![](/assets/img/2024/02/etc/default_dir_structure.png)

- 주황색 dir: 시스템 관리자나 시스템 파일들이 생성되는 곳  
- 초록색 dir: 일반 사용자 접근/사용 dir  
- 노란색 dir: 시스템 설정 존재  

## 파일 관련 기본 명령어  
### 파일 목록 보기
파일 목록 관련 기본 명령어는 다음과 같습니다.   
```sh 
$ ls  # list
```

추가 옵션을 주어 더 상세한 조회가 가능합니다.  
```sh 
$ ls -l       # long list
$ ls -a       # all, .filename.txt 등 히든 파일도 목록에서 볼 수 있음
$ ls -al
$ ls -a -l
$ ls *.txt    # 확장자가 txt인 것
```

### 파일 만들기
파일 만들기로 가장 처음 살펴볼 명령어는 `touch` 명령어입니다.  
```sh
$ touch test.txt
```
`touch` 명령어는 파일 내용을 작성한다기 보다는 기존에 있는 파일에 대해서는 파일 수정 시각을 현재 시각으로 바꾼다거나 새 파일에 대해서는 0바이트의 빈 파일을 만드는 등의 역할을 수행합니다.  

### 파일 내용 보기   
1. `cat` 명령어   
    파일 내용을 확인할 때는 `cat` 명령어를 확인할 수 있습니다.  
    ```sh
    $ cat test.txt
    ```
    `cat` 명령어는 파일 input을 standard out이라는 output으로 연결하여 화면에 내용이 출력되도록 하는 역할을 합니다.  

    `cat` 명령어와 함께 사용될 수 있는 옵션으로는 `-e` 또는 `-n` 등이 있습니다.  
    ```sh
    # 줄의 맨 뒤에 $를 붙여 눈으로 봤을 때 보이지 않는 공백까지 확인 가능  
    $ cat -e test.txt
    ```
    ![](/assets/img/2024/02/2024-02-25-linux_cli/cat_-e.png)

    ```sh
    # 줄 번호 보여주기
    cat -n test.txt
    ```
    ![](/assets/img/2024/02/2024-02-25-linux_cli/cat_-n.png)

2. `more` 명령어   
    ```sh
    $ more test.txt
    ```
    `more` 명령어는 한 번에 모든 내용을 보여주는 `cat`과 달리 현재 터미널의 크기에 출력될만큼의 내용만 보여줍니다.  
    내용을 계속해서 확인하고 싶은 경우 space를 이용한 페이지 이동, 또는 enter를 이용한 줄 단위 이동이 가능합니다.  
    단, `more`의 경우 페이지나 줄 이동이 다음으로만 가능하고 앞 내용으로 돌아갈 수는 없다는 단점이 있습니다.   

2. `less` 명령어   
    ```sh
    $ less test.txt
    ```
    `less`는 `more`를 보완한 것으로 이전 페이지로의 이동 등이 가능합니다.  
    또한 모든 파일을 메모리에 올리지 않아 `more` 대비 속도가 빠릅니다.  
    `less`는 `more`처럼 space를 이용한 페이지 이동, 또는 enter를 이용한 줄 단위 이동이 가능하며 방향키를 이용해 상하좌우 및 페이지 이동이 가능합니다.  

### 파일 삭제  
`rm` 명령어를 이용해 파일을 삭제할 수 있습니다.  
```sh
$ rm test.txt
```

### 파일 복사 / 이동  
파일 복사는 `cp` 명령어를 이용할 수 있고 파일 이동은 `mv` 명령어를 이용할 수 있습니다.   
다음은 `cp` 명령어 사용 예시입니다.  
```sh
# test1.txt를 test2.txt로 복사
$ cp test1.txt test2.txt

# test1.txt를 dir1 디렉터리 내로 복사
$ cp test1.txt dir1

# 디렉토리 dir1을 디렉토리 dir2 내로 -r 옵션을 이용하여 복사
$ cp -r dir1 dir2
```

아래는 `mv` 명령어 사용 예시입니다.  
```sh
# test1.txt를 test2.txt로 이름 변경
$ mv test1.txt test2.txt

# test1.txt를 dir1 디렉터리 내로 이동
$ mv test1.txt dir1

# 디렉토리 dir1을 디렉토리 dir2 내로 이동
$ mv dir1 dir2
```

## 디렉토리 관련 기본 명령어
### 디렉토리 생성  
디렉토리 생성은 `mkdir` 명령어를 통해 가능합니다.  
```sh
$ mkdir testdir
```
여러 depth의 디렉토리를 한 번에 생성하기 위해서는 `-p` 옵션을 사용할 수 있습니다.  
```sh
$ mkdir -p dir1/dir2/dir3
```

### 디렉토리 삭제
디렉토리 삭제는 `rmdir` 명령어를 통해 가능합니다.  
```sh
$ rmdir dir3
```

`mkdir`과 마찬가지로 `-p` 옵션을 통해 parent dir까지 한 번에 지울 수 있습니다.  
```sh
# 디렉터리 구조: ./dir1/dir2/dir 일 때

$ rmdir dir1                # dir1 Directory가 not Empty라는 오류 발생
$ rmdir -p dir1/dir2/dir3   # dir1 디렉터리 삭제 완료
```
참고로 `rm` 명령어에 `-r` 옵션을 주어 `recursive`하게 해당 디렉토리 내의 모든 파일을 삭제할 수도 있습니다.  
이 옵션은 해당 디렉터리 내의 디렉터리 뿐만 아니라 파일들까지 모두 삭제하므로 주의하여 사용해야합니다.  

## 파일 링크 관련 기본 명령어  
파일 링크는 윈도우로 따지면 바로가기를 생성하는 것과 유사한 역할을 합니다.  
링크를 걸기 위해서는 `ln` 명령어를 사용하며 아래와 같은 형식으로 활용합니다.  
```sh
$ ln [OPTION] [TARGET] [LINKNAME]
```  

링크는 원본 파일이 삭제되어도 링크 파일이 실행되는지 여부에 따라 소프트링크(심볼릭링크)와 하드 링크로 나뉘어집니다.   
소프트 링크는 원본 파일이 삭제되면 동작하지 않지만 하드 링크는 똑같은 파일이 하나 생성되며 원본 파일이 지워져도 동작이 가능합니다.   
```sh
# 심볼릭 링크 생성, -s 옵션을 주어 실행    
$ ln -s test.txt testsymlink

# 하드 링크 생성
$ ln test.txt testlink

# 파일 링크 확인  
$ ls -ali
```

소프트링크와 하드링크에 대해 더 자세히 살펴보자면, 컴퓨터에서 `파일명`이란 실제 파일의 내용을 가지고 있는 것이 아니고 해당 파일의 위치를 가르키는 포인터 역할을 합니다.   
이러한 개념이 비추어 하드링크와 소프트링크를 구분해보면 아래와 같은 차이가 있습니다.  

1. 하드링크
  - 해당 파일을 가리키는 포인터를 하나 더 만드는 것
  - 하드링크가 생성된 후에는 무엇이 원본이고 사본인지에 대한 의미는 사실상 없음
  - 파일 내용이 있는 위치는 여전히 한 곳이고 포인터만 두개로 늘어난 것
    - 파일이 10M이라고 할 떄 파일 리스트에서는 10M 파일이 두 개 생긴 것 같으나 실제로 하드디스크에서는 공간을 10M만 차지함  
2. 소프트링크 (심볼릭 링크)
  - 파일을 가리키는 포인터를 가리키는 링크  
  - 윈도우 바로가기와 매우 유사한 기능  

![](/assets/img/2024/02/2024-02-25-linux_cli/symlink_and_hardlink.png)

